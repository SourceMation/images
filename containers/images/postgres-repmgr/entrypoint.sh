#!/bin/bash
set -e

generate_repmgr_config_base() {
  mkdir -p "$(dirname "$REPMGR_CONFIG_FILE")"
  echo "--- Generating base ${REPMGR_CONFIG_FILE} ---"
  cat > "${REPMGR_CONFIG_FILE}" <<-EOF
# Repmgr configuration generated by docker-entrypoint.sh
node_id=${NODE_ID}
node_name=${NODE_NAME:-\$(hostname)}
data_directory='$PGDATA'
failover=automatic
promote_command='/usr/bin/repmgr standby promote -f "${REPMGR_CONFIG_FILE}" --log-to-file'
follow_command='/usr/bin/repmgr standby follow -f "${REPMGR_CONFIG_FILE}" --log-to-file --upstream-node-id %n'
log_level=${LOG_LEVEL:-INFO}
EOF
}

configure_postgresql() {
  echo "--- Configuring postgresql.conf for replication ---"
  cat >> "$PGDATA/postgresql.conf" <<-EOF
archive_mode = on
archive_command = 'cd .'
hot_standby = on
shared_preload_libraries = 'repmgr'
wal_level = replica
wal_log_hints = on
max_wal_senders = 10
max_replication_slots = 10
EOF
  echo "--- Configuring pg_hba.conf for replication ---"
  # Add rules to allow connections from any container on the same Docker network.
  # '0.0.0.0/0' allows all IPv4, which is acceptable for a trusted container network.
  cat >> "$PGDATA/pg_hba.conf" <<-EOF

# Repmgr replication connections
host    replication     ${REPMGR_USER}      0.0.0.0/0               md5
host    all             ${REPMGR_USER}      0.0.0.0/0               md5
EOF
}

# ==== Main Execution Logic ====
if [ -z "$1" ] || [ "${1:0:1}" = '-' ]; then
  set -- postgres "$@"
fi

if [ "$1" = 'postgres' ]; then
  : "${POSTGRES_USER?Must set POSTGRES_USER}"
  : "${POSTGRES_PASSWORD?Must set POSTGRES_PASSWORD}"
  : "${REPMGR_USER?Must set REPMGR_USER}"
  : "${REPMGR_PASSWORD?Must set REPMGR_PASSWORD}"
  
  export REPMGR_CONFIG_FILE=${REPMGR_CONFIG_FILE:-/etc/repmgr/repmgr.conf}
  generate_repmgr_config_base

  ROLE=${REPMGR_ROLE:-primary}
  
  if [ "$ROLE" = 'primary' ]; then
    CONNINFO_HOST="host=localhost"
  else
    : "${REPMGR_UPSTREAM_HOST?Must set REPMGR_UPSTREAM_HOST for standby role}"
    CONNINFO_HOST="host=$REPMGR_UPSTREAM_HOST"
  fi
  
  echo "conninfo='${CONNINFO_HOST} user=${REPMGR_USER} dbname=${REPMGR_DB} connect_timeout=2'" >> "${REPMGR_CONFIG_FILE}"
  echo "conninfo='${CONNINFO_HOST} user=${REPMGR_USER} dbname=${REPMGR_DB} connect_timeout=2'"
# Initialize the database if the data directory is empty
  echo "--- Initialize the database if empty ---"
  if [ ! -s "$PGDATA/PG_VERSION" ] && [ "$ROLE" = 'primary' ]; then
    echo "PostgreSQL data directory not found, initializing as primary..."
  
    initdb -U "$POSTGRES_USER" --pwfile=<(echo "$POSTGRES_PASSWORD")
    configure_postgresql
    pg_ctl -D "$PGDATA" -o "-c listen_addresses='localhost'" -w start
    
    # Step 1: Connect to the default 'postgres' db to create the user and database
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
      CREATE USER "${REPMGR_USER}" WITH SUPERUSER PASSWORD '${REPMGR_PASSWORD}';
      CREATE DATABASE "${REPMGR_DB}" OWNER "${REPMGR_USER}";
EOSQL

    # Step 2: Connect to the new 'repmgr' db to install the extension
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "${REPMGR_DB}" <<-EOSQL
      CREATE EXTENSION repmgr;
EOSQL
    
    pg_ctl -D "$PGDATA" -m fast -w stop
  fi

  # Start postgres in the background
  echo "--- Starting PostgreSQL ---"
  postgres &
  PG_PID=$!

  if [ "$ROLE" = 'primary' ]; then
    # Registering primary node
    echo "--- Waiting for PostgreSQL to be ready ---"
    until pg_isready -h localhost -p 5432 -U "${POSTGRES_USER}"; do
      sleep 2
    done
    if ! psql -d "${REPMGR_DB}" -U "${REPMGR_USER}" -t -c "SELECT 1 FROM repmgr.nodes WHERE node_id = ${NODE_ID} AND type = 'primary'" | grep -q 1; then
      echo "--- Registering primary node ---"
      repmgr primary register -f "${REPMGR_CONFIG_FILE}" --force
    else
      echo "--- Primary node already registered ---"
    fi
  elif [ "$ROLE" = 'standby' ]; then
    echo "--- Waiting for PostgreSQL primary node(${REPMGR_UPSTREAM_HOST}) to be ready ---"
    until pg_isready -h "${REPMGR_UPSTREAM_HOST}" -p 5432; do sleep 2; done
    echo "--- Clone primary database & register standby node ---"
    export PGPASSWORD="${REPMGR_PASSWORD}"
    repmgr standby clone -h "${REPMGR_UPSTREAM_HOST}" -U "${REPMGR_USER}" -d "${REPMGR_DB}" -D "$PGDATA" --force
    echo "--- Starting standby server ---"
    pg_ctl -D "$PGDATA" start
    echo "--- Waiting for PostgreSQL to be ready ---"
    until pg_isready -h localhost -p 5432 -U "${POSTGRES_USER}"; do
      sleep 2
    done
    echo "--- Registering standby ---"
    repmgr standby register -f "${REPMGR_CONFIG_FILE}" --force
    repmgr -h localhost -d "${REPMGR_DB}" -U "${REPMGR_USER}" -p 5432 node rejoin --verbose
    exec repmgrd -f "${REPMGR_CONFIG_FILE}"
    unset PGPASSWORD
  else
    repmgr follow register -f "${REPMGR_CONFIG_FILE}" --force
  fi

  repmgr cluster show -f "${REPMGR_CONFIG_FILE}"
  # Wait for the postgres process to exit. This keeps the container running.
  wait "$PG_PID"

else
  exec "$@"
fi